---
title: "HW1: Manipulating and visualizing spatio temporal data"
author: "STAT 574E: Environmental Statistics"
date: "DUE: 9/13 11:59pm"
output:
  html_document
  #pdf_document
header-includes:
- \renewcommand*\familydefault{\sfdefault} %% this picks a sans serif font
- \usepackage[T1]{fontenc}
---


```{r setup, echo=T}
##loading in libraries
library(ggplot2)
library(ggmap)
knitr::opts_chunk$set(class.source = 'number-lines', cache = T,
                      tigris_use_cache = T, warning = F)
```

## I. Time

Let's continue to look at the graffiti dataset from the city of San Diego. We'll focus on the records from 2021 onward. Here is how to read in the data and format the date as well as get the dates we want.
```{r graffiti}
# reading in data
data_url <- url(paste0("https://seshat.datasd.org/get_it_done_graffiti/",
                       "get_it_done_graffiti_requests_datasd.csv"))
graffiti <- read.csv(data_url)
# look at data
#View(graffiti)
Sys.sleep(3)
# setting date format
graffiti$POSIX_requested <- 
  strptime(graffiti$date_requested, format = "%Y-%m-%dT%T", tz = "America/Los_Angeles")
# set date range with 'start date'
start_date <- as.POSIXlt("2021-01-01 00:00:00", tz = "America/Los_Angeles")
graffiti <- graffiti[graffiti$POSIX_requested >= start_date, ]
```


`POSIXlt` objects have a special method for the function `hist()` in `R`. The following line of code makes a histogram with bins defined by each month of the year.
```{r}
hist(graffiti$POSIX_requested, breaks = "month", xlab = "time", main = "graffiti reports")
abline(v = seq(as.POSIXlt("2021-01-01"), as.POSIXlt("2024-01-01"), "year"), 
       col = "darkred", lwd = 2)
```

## II. Simple features

### A. Projections [10 pts]

(@) Examples of map projections: [https://xkcd.com/977/](https://xkcd.com/977/).

Let's practice projecting data using the census tracts we looked at in class. We'll start by downloading those census tracts using the `tigris` package.

```{r tracts, results = 'hide', message=FALSE}
library(tigris)

sd_tracts <- tracts(state = "CA", county = "San Diego")
#View(sd_tracts)

# try this code below if having issues getting tigris to work
#rappdirs::user_cache_dir("tigris")
#options(tigris_use_cache = TRUE)

```
Check to see what the current coordinate system for the `SpatialPolygonDataFrame` is with the `st_crs()` function in `sf`.
```{r, sd_tract}
library(sf)
st_crs(sd_tracts)
cor_sd_t <- st_crs(sd_tracts)
cor_sd_t$input
``` 

(@) Function  `st_area()` can be used to compute the areas of the census tracts in `sd_tracts`.
```{r, range.check }
# areas for each entry
areas <- st_area(sd_tracts)
# checking range
range(areas)
```

The areas we just calculated use a default method for spatially-referenced data in lat/long coordinates. Now we'll try re-projecting the census tracts for San Diego to a new coordinate reference system and see how the calculated areas change.

(@) Use the `st_transform()` function to transform the census tract polygons to the [**Universal Transverse Mercator (UTM) projection for zone 11**](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#UTM_zone) (*hint: one way to specify the CRS for UTM zone 11 is* `+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs +type=crs` *but there are others*). Call the new transformed object `sd_tracts_utm`. Compute the areas for each tract in the new coordinate system. How similar/different are the values to your answers from (7)?

```{r, transform }
#st_crs("NAD83")
# Define the target CRS for zone 11
target_crs <- st_crs(26911)
sd_tracts_utm <- st_transform(x = sd_tracts, crs = target_crs)
```

(@) [3 pts] One of the columns of data provided by the City of San Diego in `sd_tracts` is labeled `ALAND` for area of land. Compare the values of `ALAND` to the ones we just calculated ourselves. How well do they agree? What do you think might be a reason for discrepancies between the areas?

### B. Art density [15 pts]

Now let's look at a new dataset from the City of San Diego. Line 16 downloads and reads into `R` the locations of artwork in the [Civic Art Collection](https://www.sdcivicartcollection.com/portals/civic-art-collection/). 
```{r}
art <- read.csv(url("https://seshat.datasd.org/civic_art_collection/public_art_locations_datasd.csv"))
art_sf <- st_as_sf(art, coords = c("lng","lat"))
st_crs(art_sf) <- st_crs(sd_tracts)
```

(@) [2 pt] Fill in the blanks on line 17 to create the simple features object `art_sf` with an appropriate geometry defined by the locations in `art`. In your own words, explain what the code in line 18 does.
(@) [2 pt] How many total art installations are there in the collection? How many unique locations are there?

Suppose we're working for the Chief Operating Officer of the City of San Diego, and we're trying to decide where we should spend money on a new mural. There are two candidate locations: College-Roland Library (longitude -117.0561, latitude 32.76941), and Mission Valley Library (-117.1269, 32.7793). One way to help us decide where to commission a new mural might be to look at how much access our residents have to art in their neighborhoods. If there is a scarcity of art in the vicinity of one of these libraries, that might be a good place to consider.

First, we need to figure out how many pieces of art exist near these libraries. One way to summarize that information would be to figure out which census tract each library falls in, and then add up the number of art pieces in that census tract. We can use the function `st_intersection()` to do this.

The code in lines 19--20 creates a simple features object called `CRL` that represents the location of the College-Rolando Library (CRL).
```{r}
CRL <- st_as_sf(x = data.frame(lng = -117.0561, lat = 32.76941), coords = c("lng", "lat"))
st_crs(CRL) <- st_crs(sd_tracts) ## match the coordinate reference systems
```

(@) [1 pt] **PEC** that creates a simple features object called `MVL` that represents the location of the Mission Valley Library (MVL).

The code in line 21 finds the row in `sd_tracts` that corresponds to the census tract containing the CRL. From the output, we can see that the name of the tract is `29.05`.
```{r, intersect.check}
st_intersection(CRL, sd_tracts)
```

(@) [1 pt] What is the name of the census tract containing the MVL?

(@) [4 pts] Fill in the blanks below to create a new variable in the `sd_tracts` dataframe called `n_art` that gives the number of art installations in each census tract. Verify you get 12 installations in the tract with the College-Rolando Library. How many pieces of artwork are in the tract containing the MVL?
```{r}
sd_tracts$n_art <- lengths(st_intersects(sd_tracts, art_sf))
sd_tracts$n_art[sd_tracts$NAME == "29.05"]
```

(@) [5 pts] Of CLR and MVL, which census tract has a lower density of artwork (i.e., less art per square meter)? Based on your answer to the previous question, which site do you think should be selected for the mural? What's another, *new* piece of information you think would be relevant to this decision?

## III. `ggmap` [5 pts]

The package `ggmap` is an `R` package the facilitates the use of freely available map tiles from sources like [Google Maps](https://www.google.com/maps), and [Stadia Maps](https://stadiamaps.com/). These can provide great contextual visualizations for spatio-temporal data. Both of these maptile services require registration, but they both have free subscription levels that provide all the functionality we'll need. *Stadia does not require you to provide payment information.* Once you have registered, input your key using `ggmap::register_stadiamaps()`. Specifying `write = TRUE` will save your key for future instances of R. If you encounter problems with the CRAN distribution of `ggmap`, give the development version a try using `devtools::install_github("dkahle/ggmap")`.




The following exercises are designed to help you learn the basic features of `ggmap`. The code in lines 24--25 loads the `ggmap` package, then defines the variable `bbox` based on a range of longitudes and latitudes. 

```{r ggmap}
# need to create then link stadiamaps account using token
# saved Token like so -> 
#Token<- "token string goes here..."
#save(Token, file = "token.Rds")
# if using git, update or create .gitignore and put "token.Rds" or "*.Rds" in it

# .Rds files to run
load("token.Rds")

#ggmap::register_stadiamaps("1cd5e573-f515-4cef-ba79-355881e89f4f", write=T)
bbox <- c(left = -117.5, bottom = 32, right = -116.5, top = 33.5)

```

The code in line 26 uses the function `get_stadiamap()` to download tiles from Stadia. 

```{r, art.map}
art_map <- get_stadiamap(bbox = bbox)
```

The code in lines 27--28 plots the artwork locations on a background of map tiles obtained from Stadia. The `ggmap` package uses the grammar of graphics syntax used in `ggplot2`. Don't worry too much if you're not familiar with it, you'll only need the basics for our class, and there are TONS of tutorials out there if you'd like to learn more. Try out the code below and take a look at the resulting map.

```{r, map_1}

#p<- 
  ggmap(art_map) + 
  geom_point(aes(x = lng, y = lat), data = data.frame(art))
#print(p)
```

(@) [2 pts] The map shown is too zoomed out to be useful for this dataset. Try adjusting the `bbox` argument in the `get_stadiamap()` function until you have a better spatial scale. What are some good values for `bbox`?

Stadia provides some alternative map tiles that can be very visually appealing, if not always strictly necessary. Use `?get_stadiamap` to see some possible values for the arguments `maptype` and `color`.

(@) [3 pts] Explore some other combinations of `maptype` and `color`. Include your maps. Which one(s) is(are) your favorite(s)?

There are LOTS of great tutorials out there on the `ggmap` package. If you find one that resonates with you, let me know so I can post it on D2L for others.